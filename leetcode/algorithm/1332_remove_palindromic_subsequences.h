#pragma once

// https://leetcode.com/problems/remove-palindromic-subsequences/
/*
* 1332. Remove Palindromic Subsequences
* 
* You are given a string s consisting only of letters 'a' and 'b'. In a single step you can remove
* one palindromic subsequence from s.
*
* Return the minimum number of steps to make the given string empty.
*
* A string is a subsequence of a given string if it is generated by deleting some characters of a given
* string without changing its order. Note that a subsequence does not necessarily need to be contiguous.
*
* A string is called palindrome if is one that reads the same backward as well as forward.
* 
* 给定一个只包含字母 'a' 和 'b' 的字符串s。 每一步你可以从字符串s中移除一个 Palindromic子串。
* 
* 计算以此将字符串清空最少需要几步，返回步数
* 
* 字串可以是从给定字符串删除的字符组成，但不允许改变字母的顺序。字串可以不是连续的。
* 【注意这个意思是：可以跳着选字符组成字串，所以我们可以把所有的'a'都选出来组成一个字串！！！】
* 
* Palindromic字符串的定义：如果一个字符串 从头到尾 与 从尾到头 的内容相同，称之为 Palindromic字符串
* 
* 
* Example 1:
* Input: s = "ababa"
* Output: 1
* Explanation: s is already a palindrome, so its entirety can be removed in a single step.
* 
* Example 2:
* Input: s = "abb"
* Output: 2
* Explanation: "abb" -> "bb" -> "". 
* Remove palindromic subsequence "a" then "bb".
* 
* Example 3:
* Input: s = "baabb"
* Output: 2
* Explanation: "baabb" -> "b" -> "". 
* Remove palindromic subsequence "baab" then "b".
* 
* Constraints:
*   1 <= s.length <= 1000
*   s[i] is either 'a' or 'b'.
*/

#include <string>
#include <gtest/gtest.h>

namespace RemovePalindromicSubsequences {
    class Solution {
    public:
        int removePalindromeSub(std::string s) {
            /*
            * 必须要diss一下这个题目，不是算法题，而是个阅读理解，示例又在误导...
            * 注意：
            * 其实是可以从原字符串中挑选不连续的字符组成一个Palindromic子串，由于输入字符串中只会存在两个字母，
            * 所以只存在两种情况：
            * 1. 输入的字符串就是 正序逆序一致的Palindromic子串，那么只需要1步完成，返回 1
            * 2. 输入的字符串不是Palindromic子串，那么可以可以直接把它分成两个字符串，一个只包含'a',另一个只
            *    包含'b'，这样就只需2步， 返回2
            */
            return isPalindromic(s) ? 1 : 2;
        }

    private:
        inline bool isPalindromic(std::string& s) {
            std::size_t sz = s.length();
            if (sz == 1) {
                return true;
            }

            for (std::size_t i = 0; i < (sz >> 1); i++) {
                if (s.at(i) != s.at(sz - i - 1)) {
                    return false;
                }
            }
            return true;
        }
    };
}

TEST(_1332_RemovePalindromicSubsequences, SimpleCases) {
    /*
    * Example 1:
    * Input: s = "ababa"
    * Output: 1
    */
    EXPECT_EQ(RemovePalindromicSubsequences::Solution().removePalindromeSub("ababa"), 1);

    /*
    * Example 3:
    * Input: s = "baabb"
    * Output: 2
    */
    EXPECT_EQ(RemovePalindromicSubsequences::Solution().removePalindromeSub("baabb"), 2);
}